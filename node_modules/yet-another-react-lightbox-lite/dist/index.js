import { jsx, jsxs, Fragment } from 'react/jsx-runtime';
import { useContext, createContext, useState, useRef, useLayoutEffect, useCallback, useMemo, useEffect, cloneElement, isValidElement } from 'react';
import { flushSync, createPortal } from 'react-dom';

const cssPrefix = "yarll__";
function cssClass(name) {
    return `${cssPrefix}${name}`;
}
function cssVar(name) {
    return `--${cssPrefix}${name}`;
}
function clsx(...classes) {
    return [...classes].filter(Boolean).join(" ");
}
function transition(callback) {
    if (document.startViewTransition) {
        document.startViewTransition(() => {
            flushSync(callback);
        });
    }
    else {
        callback();
    }
}
function translateLabel(labels, label) {
    return labels?.[label] ?? label;
}
function translateSlideCounter(labels, index, total) {
    return translateLabel(labels, "{index} of {total}")
        .replace(/\{index}/g, `${index}`)
        .replace(/\{total}/g, `${total}`);
}
function makeUseContext(context) {
    return () => {
        const ctx = useContext(context);
        if (!ctx)
            throw new Error();
        return ctx;
    };
}
function round(value, decimals = 0) {
    const factor = 10 ** decimals;
    return Math.round((value + Number.EPSILON) * factor) / factor;
}
function scaleZoom(value, delta, factor = 100, clamp = 2) {
    return value * Math.min(1 + Math.abs(delta / factor), clamp) ** Math.sign(delta);
}
function isImageSlide(slide) {
    return (slide.type === undefined || slide.type === "image") && typeof slide.src === "string";
}
function getChildren(element) {
    return element?.children || [];
}

const LightboxContext = createContext(null);
const useLightboxContext = makeUseContext(LightboxContext);
function LightboxContextProvider({ children, ...props }) {
    return jsx(LightboxContext.Provider, { value: props, children: children });
}

function getImageDimensions(slide, rect) {
    const { width, height } = slide.srcSet?.[0] || slide;
    const imageAspectRatio = width && height ? width / height : undefined;
    const rectAspectRatio = rect.width / rect.height;
    return imageAspectRatio
        ? [
            round(imageAspectRatio < rectAspectRatio ? imageAspectRatio * rect.height : rect.width, 2),
            round(imageAspectRatio > rectAspectRatio ? rect.width / imageAspectRatio : rect.height, 2),
        ]
        : [];
}
function ImageSlide({ slide, rect, zoom }) {
    const [scale, setScale] = useState(1);
    const persistScaleTimeout = useRef(undefined);
    const { carousel: { imageProps } = {}, styles } = useLightboxContext();
    if (zoom > scale) {
        clearTimeout(persistScaleTimeout.current);
        persistScaleTimeout.current = setTimeout(() => {
            persistScaleTimeout.current = undefined;
            setScale(zoom);
        }, 300);
    }
    const srcSet = slide.srcSet
        ?.sort((a, b) => a.width - b.width)
        .map((image) => `${image.src} ${image.width}w`)
        .join(", ");
    const [width, height] = getImageDimensions(slide, rect);
    const sizes = width ? `${round(width * scale, 2)}px` : undefined;
    return (jsx("img", { draggable: false, style: styles?.image, className: cssClass("slide_image"), srcSet: srcSet, sizes: sizes, width: width, height: height, src: slide.src, alt: slide.alt ?? "", ...imageProps }));
}

const ZoomContext = createContext(null);
const useZoom = makeUseContext(ZoomContext);
const ZoomInternalContext = createContext(null);
const useZoomInternal = makeUseContext(ZoomInternalContext);
function Zoom({ children }) {
    const [zoom, setZoom] = useState(1);
    const [offsetX, setOffsetX] = useState(0);
    const [offsetY, setOffsetY] = useState(0);
    const [rect, setRect] = useState();
    const observer = useRef(undefined);
    const carouselRef = useRef(null);
    const { index, slides, zoom: { supports, disabled } = {} } = useLightboxContext();
    const [prevIndex, setPrevIndex] = useState(index);
    if (index !== prevIndex) {
        setZoom(1);
        setOffsetX(0);
        setOffsetY(0);
        setPrevIndex(index);
    }
    const slide = slides[index];
    const maxZoom = (isImageSlide(slide) && !disabled) || (supports || []).includes(slide.type)
        ? 8
        : 1;
    useLayoutEffect(() => {
        const carouselHalfWidth = (rect?.width || 0) / 2;
        const carouselHalfHeight = (rect?.height || 0) / 2;
        const [slideHalfWidth, slideHalfHeight] = Array.from(getChildren(Array.from(getChildren(carouselRef.current)).find((node) => node instanceof HTMLElement && !node.hidden)))
            .filter((node) => node instanceof HTMLElement)
            .map((node) => [
            Math.max(carouselHalfWidth - node.offsetLeft, node.offsetLeft + node.offsetWidth - carouselHalfWidth),
            Math.max(carouselHalfHeight - node.offsetTop, node.offsetTop + node.offsetHeight - carouselHalfHeight),
        ])
            .reduce(([maxWidth, maxHeight], [width, height]) => [Math.max(width, maxWidth), Math.max(height, maxHeight)], [0, 0]);
        const maxOffsetX = Math.max(slideHalfWidth * zoom - carouselHalfWidth, 0);
        const maxOffsetY = Math.max(slideHalfHeight * zoom - carouselHalfHeight, 0);
        setOffsetX(Math.min(maxOffsetX, Math.max(-maxOffsetX, offsetX)));
        setOffsetY(Math.min(maxOffsetY, Math.max(-maxOffsetY, offsetY)));
    }, [zoom, rect, offsetX, offsetY]);
    const setCarouselRef = useCallback((node) => {
        carouselRef.current = node;
        observer.current?.disconnect();
        observer.current = undefined;
        const updateRect = () => setRect(node ? { width: node.clientWidth, height: node.clientHeight } : undefined);
        if (node && typeof ResizeObserver !== "undefined") {
            observer.current = new ResizeObserver(updateRect);
            observer.current.observe(node);
        }
        else {
            updateRect();
        }
    }, []);
    const changeOffsets = useCallback((dx, dy) => {
        setOffsetX(offsetX + dx);
        setOffsetY(offsetY + dy);
    }, [offsetX, offsetY]);
    const changeZoom = useCallback((targetZoom, event) => {
        const newZoom = Math.min(Math.max(targetZoom, 1), maxZoom);
        setZoom(newZoom);
        if (event && carouselRef.current) {
            const { clientX, clientY } = event;
            const { left, top, width, height } = carouselRef.current.getBoundingClientRect();
            const zoomDelta = newZoom / zoom - 1;
            changeOffsets((left + width / 2 + offsetX - clientX) * zoomDelta, (top + height / 2 + offsetY - clientY) * zoomDelta);
        }
    }, [zoom, maxZoom, offsetX, offsetY, changeOffsets]);
    const context = useMemo(() => ({ rect, zoom, maxZoom, offsetX, offsetY, changeZoom, changeOffsets }), [rect, zoom, maxZoom, offsetX, offsetY, changeZoom, changeOffsets]);
    const internalContext = useMemo(() => ({ carouselRef, setCarouselRef }), [setCarouselRef]);
    return (jsx(ZoomContext.Provider, { value: context, children: jsx(ZoomInternalContext.Provider, { value: internalContext, children: children }) }));
}

function CarouselSlide({ slide, rect, current, slideIndex, }) {
    const ref = useRef(null);
    const { zoom, offsetX, offsetY } = useZoom();
    const { slides, styles, labels, render: { slide: renderSlide, slideHeader, slideFooter } = {}, } = useLightboxContext();
    useEffect(() => {
        if (!current && ref.current?.contains(document.activeElement)) {
            ref.current.closest('[tabindex="-1"]')?.focus();
        }
    }, [current]);
    const context = { slide, rect, current, slideIndex, zoom: round(current ? zoom : 1, 3) };
    return (jsxs("div", { ref: ref, role: "group", "aria-label": translateSlideCounter(labels, slideIndex + 1, slides.length), "aria-roledescription": translateLabel(labels, "Slide"), className: cssClass("slide"), hidden: !current, style: {
            transform: current && zoom > 1
                ? `translateX(${round(offsetX, 3)}px) translateY(${round(offsetY, 3)}px) scale(${round(zoom, 3)})`
                : undefined,
            ...styles?.slide,
        }, children: [slideHeader?.(context), renderSlide?.(context) ??
                (isImageSlide(slide) && jsx(ImageSlide, { ...context })), slideFooter?.(context)] }));
}
function Carousel() {
    const { slides, index, styles, labels, carousel: { preload = 2 } = {} } = useLightboxContext();
    const { setCarouselRef } = useZoomInternal();
    const { rect } = useZoom();
    return (jsx("div", { ref: setCarouselRef, style: styles?.carousel, className: cssClass("carousel"), role: "region", "aria-live": "polite", "aria-label": translateLabel(labels, "Photo gallery"), "aria-roledescription": translateLabel(labels, "Carousel"), children: rect &&
            Array.from({ length: 2 * preload + 1 }).map((_, i) => {
                const slideIndex = index - preload + i;
                if (slideIndex < 0 || slideIndex >= slides.length)
                    return null;
                const slide = slides[slideIndex];
                return (jsx(CarouselSlide, { rect: rect, slide: slide, slideIndex: slideIndex, current: slideIndex === index }, slide.key ?? [`${slideIndex}`, isImageSlide(slide) && slide.src].filter(Boolean).join("|")));
            }) }));
}

const ControllerContext = createContext(null);
const useController = makeUseContext(ControllerContext);
function Controller({ setIndex, children }) {
    const { slides, index } = useLightboxContext();
    const exitHooks = useRef([]);
    const context = useMemo(() => {
        const prev = () => {
            if (index > 0)
                transition(() => setIndex(index - 1));
        };
        const next = () => {
            if (index < slides.length - 1)
                transition(() => setIndex(index + 1));
        };
        const close = () => {
            Promise.all(exitHooks.current.map((hook) => hook()))
                .catch(() => { })
                .then(() => {
                exitHooks.current = [];
                setIndex(-1);
            });
        };
        const addExitHook = (hook) => {
            exitHooks.current.push(hook);
            return () => {
                exitHooks.current.splice(exitHooks.current.indexOf(hook), 1);
            };
        };
        return { prev, next, close, addExitHook };
    }, [slides.length, index, setIndex]);
    return jsx(ControllerContext.Provider, { value: context, children: children });
}

function Button({ icon: Icon, renderIcon, label, onClick, disabled, className }) {
    const { labels, styles } = useLightboxContext();
    const buttonLabel = translateLabel(labels, label);
    return (jsx("button", { type: "button", title: buttonLabel, "aria-label": buttonLabel, onClick: onClick, disabled: disabled, style: styles?.button, className: clsx(cssClass("button"), className), children: renderIcon?.() ?? jsx(Icon, { style: styles?.icon, className: cssClass("icon") }) }));
}

function svgIcon(name, children) {
    const icon = (props) => (jsx("svg", { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24", width: "24", height: "24", "aria-hidden": "true", focusable: "false", ...props, children: children }));
    icon.displayName = name;
    return icon;
}
function createIcon(name, glyph) {
    return svgIcon(name, jsxs("g", { fill: "currentColor", children: [jsx("path", { d: "M0 0h24v24H0z", fill: "none" }), glyph] }));
}

const Close = createIcon("Close", jsx("path", { d: "M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z" }));

const Next = createIcon("Next", jsx("path", { d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z" }));

const Previous = createIcon("Previous", jsx("path", { d: "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z" }));

function Navigation() {
    const { slides, index, render: { iconPrev, iconNext, controls } = {} } = useLightboxContext();
    const { prev, next } = useController();
    return (jsxs(Fragment, { children: [slides.length > 1 && (jsxs(Fragment, { children: [jsx(Button, { label: "Previous", icon: Previous, renderIcon: iconPrev, onClick: prev, className: cssClass("button_prev"), disabled: index <= 0 }), jsx(Button, { label: "Next", icon: Next, renderIcon: iconNext, onClick: next, className: cssClass("button_next"), disabled: index >= slides.length - 1 })] })), controls?.()] }));
}

const WHEEL_ZOOM_FACTOR = 100;
const WHEEL_SWIPE_DISTANCE = 100;
const WHEEL_SWIPE_COOLDOWN_TIME = 1000;
const POINTER_SWIPE_DISTANCE = 100;
const KEYBOARD_ZOOM_FACTOR = 8 ** (1 / 4);
const KEYBOARD_MOVE_DISTANCE = 50;
const PINCH_ZOOM_DISTANCE_FACTOR = 100;
const PREVAILING_DIRECTION_FACTOR = 1.2;
function distance(pointerA, pointerB) {
    return ((pointerA.clientX - pointerB.clientX) ** 2 + (pointerA.clientY - pointerB.clientY) ** 2) ** 0.5;
}
function useSensors() {
    const wheelEvents = useRef([]);
    const wheelCooldown = useRef(null);
    const wheelCooldownMomentum = useRef(null);
    const activePointers = useRef([]);
    const pinchZoomDistance = useRef(undefined);
    const { zoom, maxZoom, changeZoom, changeOffsets } = useZoom();
    const { carouselRef } = useZoomInternal();
    const { prev, next, close } = useController();
    const { closeOnPullUp, closeOnPullDown, closeOnBackdropClick } = {
        closeOnPullUp: true,
        closeOnPullDown: true,
        closeOnBackdropClick: true,
        ...useLightboxContext().controller,
    };
    return useMemo(() => {
        const onKeyDown = (event) => {
            const { key, metaKey, ctrlKey } = event;
            const meta = metaKey || ctrlKey;
            const preventDefault = () => event.preventDefault();
            const handleChangeZoom = (newZoom) => {
                preventDefault();
                changeZoom(newZoom);
            };
            if (key === "+" || (meta && key === "="))
                handleChangeZoom(zoom * KEYBOARD_ZOOM_FACTOR);
            if (key === "-" || (meta && key === "_"))
                handleChangeZoom(zoom / KEYBOARD_ZOOM_FACTOR);
            if (meta && key === "0")
                handleChangeZoom(1);
            if (key === "Escape")
                close();
            if (zoom > 1) {
                const move = (deltaX, deltaY) => {
                    preventDefault();
                    changeOffsets(deltaX, deltaY);
                };
                if (key === "ArrowUp")
                    move(0, KEYBOARD_MOVE_DISTANCE);
                if (key === "ArrowDown")
                    move(0, -KEYBOARD_MOVE_DISTANCE);
                if (key === "ArrowLeft")
                    move(KEYBOARD_MOVE_DISTANCE, 0);
                if (key === "ArrowRight")
                    move(-KEYBOARD_MOVE_DISTANCE, 0);
                return;
            }
            if (key === "ArrowLeft")
                prev();
            if (key === "ArrowRight")
                next();
        };
        const removePointer = (event) => {
            const pointers = activePointers.current;
            pointers.splice(0, pointers.length, ...pointers.filter((pointer) => pointer.pointerId !== event.pointerId));
        };
        const addPointer = (event) => {
            event.persist();
            removePointer(event);
            activePointers.current.push(event);
        };
        const shouldIgnoreEvent = (event) => ("pointerType" in event && event.pointerType === "mouse" && event.buttons > 1) ||
            (event.target instanceof Element &&
                (event.target.classList.contains(cssClass("button")) ||
                    event.target.classList.contains(cssClass("icon")) ||
                    Array.from(carouselRef.current?.parentElement?.querySelectorAll(`.${cssClass("toolbar")}, .${cssClass("selectable")}`) || []).find((element) => element.contains(event.target)) !== undefined));
        const onPointerDown = (event) => {
            if (shouldIgnoreEvent(event))
                return;
            addPointer(event);
            const pointers = activePointers.current;
            if (pointers.length === 2) {
                pinchZoomDistance.current = distance(pointers[0], pointers[1]);
            }
        };
        const onPointerMove = (event) => {
            const pointers = activePointers.current;
            const activePointer = pointers.find((pointer) => pointer.pointerId === event.pointerId);
            if (!activePointer)
                return;
            if (pointers.length === 2 && pinchZoomDistance.current) {
                addPointer(event);
                const currentDistance = distance(pointers[0], pointers[1]);
                const delta = currentDistance - pinchZoomDistance.current;
                if (Math.abs(delta) > 0) {
                    changeZoom(scaleZoom(zoom, delta, PINCH_ZOOM_DISTANCE_FACTOR), {
                        clientX: (pointers[0].clientX + pointers[1].clientX) / 2,
                        clientY: (pointers[0].clientY + pointers[1].clientY) / 2,
                    });
                    pinchZoomDistance.current = currentDistance;
                }
                return;
            }
            if (zoom > 1) {
                if (pointers.length === 1) {
                    changeOffsets(event.clientX - activePointer.clientX, event.clientY - activePointer.clientY);
                }
                addPointer(event);
            }
        };
        const onPointerUp = (event) => {
            const pointers = activePointers.current;
            const activePointer = pointers.find((pointer) => pointer.pointerId === event.pointerId);
            if (!activePointer)
                return;
            if (pointers.length === 1 && zoom === 1) {
                const dx = event.clientX - activePointer.clientX;
                const dy = event.clientY - activePointer.clientY;
                const deltaX = Math.abs(dx);
                const deltaY = Math.abs(dy);
                if (deltaX > POINTER_SWIPE_DISTANCE && deltaX > PREVAILING_DIRECTION_FACTOR * deltaY) {
                    if (dx > 0) {
                        prev();
                    }
                    else {
                        next();
                    }
                }
                else if ((deltaY > POINTER_SWIPE_DISTANCE &&
                    deltaY > PREVAILING_DIRECTION_FACTOR * deltaX &&
                    ((closeOnPullUp && dy < 0) || (closeOnPullDown && dy > 0))) ||
                    (closeOnBackdropClick &&
                        activePointer.target instanceof Element &&
                        Array.from(activePointer.target.classList).some((className) => [cssClass("slide"), cssClass("portal")].includes(className)))) {
                    close();
                }
            }
            removePointer(event);
        };
        const onWheel = (event) => {
            if (event.ctrlKey) {
                if (Math.abs(event.deltaY) > Math.abs(event.deltaX)) {
                    changeZoom(scaleZoom(zoom, -event.deltaY, WHEEL_ZOOM_FACTOR), event);
                }
                return;
            }
            if (zoom > 1) {
                changeOffsets(-event.deltaX, -event.deltaY);
                return;
            }
            if (wheelCooldown.current && wheelCooldownMomentum.current) {
                if (event.deltaX * wheelCooldownMomentum.current > 0 &&
                    (event.timeStamp <= wheelCooldown.current + WHEEL_SWIPE_COOLDOWN_TIME / 2 ||
                        (event.timeStamp <= wheelCooldown.current + WHEEL_SWIPE_COOLDOWN_TIME &&
                            Math.abs(event.deltaX) < PREVAILING_DIRECTION_FACTOR * Math.abs(wheelCooldownMomentum.current)))) {
                    wheelCooldownMomentum.current = event.deltaX;
                    return;
                }
                wheelCooldown.current = null;
                wheelCooldownMomentum.current = null;
            }
            event.persist();
            wheelEvents.current = wheelEvents.current.filter((e) => e.timeStamp > event.timeStamp - 3000);
            wheelEvents.current.push(event);
            const dx = wheelEvents.current.map((e) => e.deltaX).reduce((a, b) => a + b, 0);
            const deltaX = Math.abs(dx);
            const deltaY = Math.abs(wheelEvents.current.map((e) => e.deltaY).reduce((a, b) => a + b, 0));
            if (deltaX > WHEEL_SWIPE_DISTANCE && deltaX > PREVAILING_DIRECTION_FACTOR * deltaY) {
                if (dx < 0) {
                    prev();
                }
                else {
                    next();
                }
                wheelEvents.current = [];
                wheelCooldown.current = event.timeStamp;
                wheelCooldownMomentum.current = event.deltaX;
            }
        };
        const onDoubleClick = (event) => {
            if (shouldIgnoreEvent(event))
                return;
            changeZoom(zoom < maxZoom ? scaleZoom(zoom, 2, 1) : 1, event);
        };
        return {
            onKeyDown,
            onPointerDown,
            onPointerMove,
            onPointerUp,
            onPointerLeave: onPointerUp,
            onPointerCancel: onPointerUp,
            onDoubleClick,
            onWheel,
        };
    }, [
        prev,
        next,
        close,
        zoom,
        maxZoom,
        changeZoom,
        changeOffsets,
        carouselRef,
        closeOnPullUp,
        closeOnPullDown,
        closeOnBackdropClick,
    ]);
}

function setAttribute(element, attribute, value) {
    const previousValue = element.getAttribute(attribute);
    element.setAttribute(attribute, value);
    return () => {
        if (previousValue !== null) {
            element.setAttribute(attribute, previousValue);
        }
        else {
            element.removeAttribute(attribute);
        }
    };
}
function Portal({ children }) {
    const { labels, styles, className } = useLightboxContext();
    const cleanup = useRef([]);
    const [mounted, setMounted] = useState(false);
    const [visible, setVisible] = useState(false);
    const onTransitionEnd = useRef(undefined);
    const restoreFocus = useRef(null);
    const sensors = useSensors();
    const { addExitHook } = useController();
    const handleCleanup = useCallback(() => {
        cleanup.current.forEach((cleaner) => cleaner());
        cleanup.current = [];
    }, []);
    useEffect(() => addExitHook(() => new Promise((resolve) => {
        onTransitionEnd.current = () => {
            onTransitionEnd.current = undefined;
            resolve();
        };
        handleCleanup();
        setVisible(false);
    })), [addExitHook, handleCleanup]);
    useEffect(() => {
        const property = cssVar("scrollbar-width");
        const scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
        if (scrollbarWidth > 0) {
            document.documentElement.style.setProperty(property, `${scrollbarWidth}px`);
        }
        return () => {
            if (scrollbarWidth > 0) {
                document.documentElement.style.removeProperty(property);
            }
        };
    }, []);
    useEffect(() => {
        setMounted(true);
        return () => setMounted(false);
    }, []);
    const handleRef = useCallback((node) => {
        if (node) {
            node.focus();
            const preventWheelDefaults = (event) => event.preventDefault();
            node.addEventListener("wheel", preventWheelDefaults, { passive: false });
            cleanup.current.push(() => {
                node.removeEventListener("wheel", preventWheelDefaults);
            });
            const elements = getChildren(node.parentElement);
            for (let i = 0; i < elements.length; i += 1) {
                const element = elements[i];
                if (!["TEMPLATE", "SCRIPT", "STYLE"].includes(element.tagName) && element !== node) {
                    cleanup.current.push(setAttribute(element, "inert", ""));
                    cleanup.current.push(setAttribute(element, "aria-hidden", "true"));
                }
            }
            cleanup.current.push(() => {
                restoreFocus.current?.focus?.();
                restoreFocus.current = null;
            });
            setVisible(true);
        }
        else {
            handleCleanup();
        }
    }, [handleCleanup]);
    return mounted
        ? createPortal(jsx("div", { "aria-modal": true, role: "dialog", "aria-label": translateLabel(labels, "Lightbox"), tabIndex: -1, ref: handleRef, style: styles?.portal, className: clsx(cssClass("portal"), !visible && cssClass("portal_closed"), className), onTransitionEnd: onTransitionEnd.current, onFocus: (event) => {
                if (!restoreFocus.current) {
                    restoreFocus.current = event.relatedTarget;
                }
            }, ...sensors, children: children }), document.body)
        : null;
}

function Toolbar() {
    const { render: { iconClose } = {}, toolbar: { buttons, fixed } = {}, styles } = useLightboxContext();
    const { close } = useController();
    return (jsxs("div", { style: styles?.toolbar, className: clsx(cssClass("toolbar"), fixed && cssClass("toolbar_fixed")), children: [buttons?.map((button, key) => (isValidElement(button) && !button.key ? cloneElement(button, { key }) : button)), jsx(Button, { label: "Close", icon: Close, renderIcon: iconClose, onClick: close })] }));
}

function Lightbox({ slides, index, setIndex, ...rest }) {
    if (!Array.isArray(slides) || index === undefined || index < 0 || index >= slides.length)
        return null;
    return (jsx(LightboxContextProvider, { slides, index, ...rest, children: jsx(Controller, { setIndex, children: jsx(Zoom, { children: jsxs(Portal, { children: [jsx(Toolbar, {}), jsx(Carousel, {}), jsx(Navigation, {})] }) }) }) }));
}

export { Lightbox as default, useZoom };
